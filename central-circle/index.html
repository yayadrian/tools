<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Central Circle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <style>*{box-sizing:border-box}
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
    margin: 0;
    background: #f7f7f7;
    color: #111;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }
  header {
    padding: 1.5rem 1rem 0;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 1rem;
    flex-wrap: wrap;
  }
  .header-content {
    flex: 1;
  }
  .header-controls {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.75rem;
    min-width: 220px;
  }
  .slider-control {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.35rem;
    background: white;
    border: 2px solid #222;
    border-radius: 12px;
    padding: 0.5rem 0.75rem;
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    width: clamp(200px, 32vw, 260px);
  }
  .slider-label {
    font-weight: 600;
    font-size: 0.9rem;
    color: #222;
  }
  .slider-value {
    font-size: 0.85rem;
    color: #444;
  }
  .slider-input {
    width: 100%;
    accent-color: #222;
  }
  .unit-toggle {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    background: white;
    border: 2px solid #222;
    border-radius: 999px;
    padding: 0.35rem;
    font-size: 0.9rem;
    font-weight: 600;
    white-space: nowrap;
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
  }
  .unit-option {
    border: none;
    background: transparent;
    color: #222;
    padding: 0.35rem 0.9rem;
    border-radius: 999px;
    cursor: pointer;
    transition: background 0.2s, color 0.2s, box-shadow 0.2s;
  }
  .unit-option:hover {
    background: rgba(34, 34, 34, 0.08);
  }
  .unit-option:focus-visible {
    outline: 2px solid #0a58ca;
    outline-offset: 2px;
  }
  .unit-option.active {
    background: #222;
    color: white;
    box-shadow: 0 2px 8px rgba(0,0,0,0.25);
  }
  h1 {
    margin: 0 0 .5rem;
    font-size: 1.75rem;
  }
  p {
    margin: 0 0 1rem;
    font-size: 1rem;
    line-height: 1.5;
  }
  main {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    padding: 0 1rem 1.5rem;
  }
  #map {
    flex: 1;
    min-height: 420px;
    border: 2px solid #222;
    border-radius: 8px;
  }
  footer {
    font-size: .9rem;
    color: #444;
    padding: 0 1rem 1.5rem;
  }
  a {
    color: #0645ad;
  }
  .ring-label-marker {
    background: transparent;
    border: none;
  }
  .ring-label {
    background: rgba(255, 255, 255, 0.9);
    border: 2px solid #222;
    border-radius: 4px;
    padding: 4px 8px;
    font-weight: 600;
    font-size: 14px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    white-space: nowrap;
  }
  .video-config {
    background: white;
    border: 2px solid #222;
    border-radius: 12px;
    padding: 0.75rem;
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    margin-bottom: 1rem;
  }
  .video-config-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    user-select: none;
  }
  .video-config-header h2 {
    margin: 0;
    font-size: 1rem;
    font-weight: 600;
  }
  .collapse-toggle {
    background: none;
    border: none;
    font-size: 1.2rem;
    cursor: pointer;
    padding: 0.25rem;
    transition: transform 0.2s;
  }
  .collapse-toggle.collapsed {
    transform: rotate(-90deg);
  }
  .video-config-content {
    margin-top: 0.75rem;
  }
  .video-config-content.hidden {
    display: none;
  }
  .video-form {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 0.75rem;
    flex-wrap: wrap;
  }
  .video-form input {
    flex: 1;
    min-width: 200px;
    padding: 0.5rem;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-size: 0.9rem;
  }
  .video-form button {
    padding: 0.5rem 1rem;
    background: #222;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.9rem;
    transition: background 0.2s;
  }
  .video-form button:hover {
    background: #444;
  }
  .video-feed-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  .video-feed-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem;
    background: #f7f7f7;
    border: 1px solid #ddd;
    border-radius: 6px;
  }
  .video-feed-name {
    flex: 1;
    font-size: 0.9rem;
    font-weight: 500;
  }
  .video-feed-controls {
    display: flex;
    gap: 0.25rem;
  }
  .video-feed-controls button {
    padding: 0.25rem 0.5rem;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: background 0.2s;
  }
  .video-feed-controls button:hover {
    background: #f0f0f0;
  }
  .video-feed-controls button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  .video-container {
    margin-top: 1rem;
    display: grid;
    gap: 1rem;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  }
  .video-tile {
    background: #000;
    border: 2px solid #222;
    border-radius: 8px;
    overflow: hidden;
    aspect-ratio: 16 / 9;
  }
  .video-tile video {
    width: 100%;
    height: 100%;
    object-fit: contain;
  }
  </style>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.6/dist/hls.min.js" crossorigin="anonymous"></script>
</head>
<body>
  <header>
    <div class="header-content">
      <h1>Central Circle</h1>
  <p id="description">Click anywhere on the map to draw concentric distance rings around that point. Use the slider to change the spacing between the circles.</p>
    </div>
    <div class="header-controls">
      <div class="slider-control">
        <label for="ring-spacing-slider" class="slider-label">Ring spacing</label>
        <div id="ring-spacing-value" class="slider-value" aria-live="polite">50 km</div>
        <input type="range" id="ring-spacing-slider" min="10" max="150" step="5" value="50" class="slider-input" aria-label="Adjust ring spacing in kilometres" aria-valuemin="10" aria-valuemax="150" aria-valuenow="50">
      </div>
      <div class="unit-toggle" role="radiogroup" aria-label="Choose measurement units">
        <button type="button" class="unit-option active" data-unit="km" role="radio" aria-checked="true" aria-pressed="true" aria-label="Use kilometres" tabindex="0">Km</button>
        <button type="button" class="unit-option" data-unit="mi" role="radio" aria-checked="false" aria-pressed="false" aria-label="Use miles" tabindex="-1">Miles</button>
      </div>
    </div>
  </header>
  <main>
    <div class="video-config">
      <div class="video-config-header" id="videoConfigHeader">
        <h2>Video Feeds</h2>
        <button class="collapse-toggle" id="collapseToggle" aria-label="Toggle video configuration">▼</button>
      </div>
      <div class="video-config-content" id="videoConfigContent">
        <form class="video-form" id="videoForm">
          <input type="url" id="videoUrl" placeholder="https://example.com/stream.m3u8" required>
          <button type="submit">Add Feed</button>
        </form>
        <div class="video-feed-list" id="videoFeedList"></div>
      </div>
    </div>
    <div class="video-container" id="videoContainer"></div>
    <div id="map" role="region" aria-label="Interactive map for drawing concentric circles"></div>
  </main>
  <footer>
    
  </footer>
  <script>
document.addEventListener('DOMContentLoaded', function() {
  // Video Feed Management - initialized first to ensure it works even if map fails
  const videoForm = document.getElementById('videoForm');
  const videoUrlInput = document.getElementById('videoUrl');
  const videoFeedList = document.getElementById('videoFeedList');
  const videoContainer = document.getElementById('videoContainer');
  const videoConfigHeader = document.getElementById('videoConfigHeader');
  const videoConfigContent = document.getElementById('videoConfigContent');
  const collapseToggle = document.getElementById('collapseToggle');
  
  const hlsPlayers = new Map();
  let videoFeeds = [];

  // Collapse/expand functionality
  videoConfigHeader.addEventListener('click', () => {
    const isCollapsed = videoConfigContent.classList.toggle('hidden');
    collapseToggle.classList.toggle('collapsed', isCollapsed);
    collapseToggle.setAttribute('aria-expanded', !isCollapsed);
  });

  // Extract feed name from URL
  function getFeedName(url) {
    try {
      const urlObj = new URL(url);
      const pathname = urlObj.pathname;
      const filename = pathname.split('/').pop();
      // Remove extension if present
      return filename.replace(/\.[^/.]+$/, '') || 'Feed';
    } catch {
      return 'Feed';
    }
  }

  // Render video feed list
  function renderFeedList() {
    videoFeedList.innerHTML = '';
    
    videoFeeds.forEach((feed, index) => {
      const item = document.createElement('div');
      item.className = 'video-feed-item';
      
      const name = document.createElement('span');
      name.className = 'video-feed-name';
      name.textContent = feed.name;
      
      const controls = document.createElement('div');
      controls.className = 'video-feed-controls';
      
      const upBtn = document.createElement('button');
      upBtn.textContent = '↑';
      upBtn.title = 'Move up';
      upBtn.disabled = index === 0;
      upBtn.addEventListener('click', () => moveUp(index));
      
      const downBtn = document.createElement('button');
      downBtn.textContent = '↓';
      downBtn.title = 'Move down';
      downBtn.disabled = index === videoFeeds.length - 1;
      downBtn.addEventListener('click', () => moveDown(index));
      
      const reloadBtn = document.createElement('button');
      reloadBtn.textContent = '↻';
      reloadBtn.title = 'Reload feed';
      reloadBtn.addEventListener('click', () => reloadFeed(index));
      
      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = '✕';
      deleteBtn.title = 'Delete feed';
      deleteBtn.addEventListener('click', () => deleteFeed(index));
      
      controls.appendChild(upBtn);
      controls.appendChild(downBtn);
      controls.appendChild(reloadBtn);
      controls.appendChild(deleteBtn);
      
      item.appendChild(name);
      item.appendChild(controls);
      videoFeedList.appendChild(item);
    });
  }

  // Render video tiles
  function renderVideoTiles() {
    videoContainer.innerHTML = '';
    
    videoFeeds.forEach((feed) => {
      const tile = document.createElement('div');
      tile.className = 'video-tile';
      
      const video = document.createElement('video');
      video.controls = true;
      video.muted = true;
      video.playsInline = true;
      
      tile.appendChild(video);
      videoContainer.appendChild(tile);
      
      attachStream(video, feed.url);
    });
  }

  // Attach stream to video element
  function attachStream(video, url) {
    if (video.canPlayType('application/vnd.apple.mpegurl')) {
      video.src = url;
    } else if (window.Hls && window.Hls.isSupported()) {
      const hls = new Hls({
        enableWorker: true,
        backBufferLength: 90,
        maxLoadingTimeout: 30000,
        maxRetries: 3,
      });
      hls.loadSource(url);
      hls.attachMedia(video);
      hlsPlayers.set(video, hls);
    } else {
      video.src = url;
    }
    
    const tryPlay = () => {
      const playPromise = video.play();
      if (playPromise && typeof playPromise.catch === 'function') {
        playPromise.catch(() => {
          // Autoplay might be blocked
        });
      }
    };
    
    video.addEventListener('loadedmetadata', tryPlay, { once: true });
  }

  // Clean up HLS player
  function cleanupVideo(video) {
    const hlsInstance = hlsPlayers.get(video);
    if (hlsInstance) {
      hlsInstance.destroy();
      hlsPlayers.delete(video);
    }
    video.pause();
    video.removeAttribute('src');
    video.load();
  }

  // Add feed
  function addFeed(url) {
    const name = getFeedName(url);
    videoFeeds.push({ url, name });
    renderFeedList();
    renderVideoTiles();
  }

  // Move feed up
  function moveUp(index) {
    if (index > 0) {
      [videoFeeds[index - 1], videoFeeds[index]] = [videoFeeds[index], videoFeeds[index - 1]];
      renderFeedList();
      renderVideoTiles();
    }
  }

  // Move feed down
  function moveDown(index) {
    if (index < videoFeeds.length - 1) {
      [videoFeeds[index], videoFeeds[index + 1]] = [videoFeeds[index + 1], videoFeeds[index]];
      renderFeedList();
      renderVideoTiles();
    }
  }

  // Reload feed
  function reloadFeed(index) {
    const feed = videoFeeds[index];
    // Get the video element at this index
    const videos = videoContainer.querySelectorAll('video');
    if (videos[index]) {
      cleanupVideo(videos[index]);
      // Re-attach stream
      setTimeout(() => {
        attachStream(videos[index], feed.url);
      }, 100);
    }
  }

  // Delete feed
  function deleteFeed(index) {
    const videos = videoContainer.querySelectorAll('video');
    if (videos[index]) {
      cleanupVideo(videos[index]);
    }
    videoFeeds.splice(index, 1);
    renderFeedList();
    renderVideoTiles();
  }

  // Form submission
  videoForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const url = videoUrlInput.value.trim();
    if (url) {
      addFeed(url);
      videoUrlInput.value = '';
    }
  });

  // Initialize the map (wrapped in try-catch so video feeds still work if map fails)
  try {
    const map = L.map('map', {
      center: [51.5074, -0.1278],
      zoom: 7,
      worldCopyJump: true
    });

    // Add OpenStreetMap tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 18,
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

  const baseMultipliers = [1, 2, 4, 6];

  // Get DOM elements
  const unitOptions = Array.from(document.querySelectorAll('.unit-option'));
  const description = document.getElementById('description');
  const ringSpacingSlider = document.getElementById('ring-spacing-slider');
  const ringSpacingValue = document.getElementById('ring-spacing-value');

  // Unit system: true = miles, false = kilometres
  let useMiles = false;
  let baseSpacingKm = Number(ringSpacingSlider.value);
  
  function getRingDistancesKm() {
    return baseMultipliers.map(multiplier => baseSpacingKm * multiplier);
  }

  function getDistancesForDisplay() {
    const ringDistances = getRingDistancesKm();
    return useMiles
      ? ringDistances.map(distanceKm => Math.round(distanceKm * 0.621371))
      : ringDistances.map(distanceKm => Math.round(distanceKm));
  }

  function updateDescription() {
    const distances = getDistancesForDisplay();
    const unit = useMiles ? 'miles' : 'kilometres';
    description.textContent = `Click anywhere on the map to draw concentric distance rings around that point. Use the slider to change the spacing. Circles are currently at ${distances.join(', ')} ${unit}`;
  }

  function updateSliderDisplay() {
    const displayValue = useMiles
      ? Math.round(baseSpacingKm * 0.621371)
      : Math.round(baseSpacingKm);
    const unit = useMiles ? 'mi' : 'km';
    ringSpacingValue.textContent = `${displayValue} ${unit}`;
    ringSpacingSlider.setAttribute('aria-valuenow', baseSpacingKm.toString());
    ringSpacingSlider.setAttribute('aria-valuetext', `${displayValue} ${unit}`);
    ringSpacingSlider.setAttribute('aria-label', `Adjust ring spacing in ${unit === 'km' ? 'kilometres' : 'miles'}`);
  }

  const markerLayer = L.layerGroup().addTo(map);
  const ringsLayer = L.layerGroup().addTo(map);

  function refreshRingsIfNeeded() {
    if (markerLayer.getLayers().length > 0) {
      const centerMarker = markerLayer.getLayers()[0];
      drawCentralRings(centerMarker.getLatLng());
    }
  }

  function setUnitSelection(selectedUnit) {
    const shouldUseMiles = selectedUnit === 'mi';
    useMiles = shouldUseMiles;

    unitOptions.forEach(option => {
      const isActive = option.dataset.unit === selectedUnit;
      option.classList.toggle('active', isActive);
      option.setAttribute('aria-checked', isActive);
      option.setAttribute('aria-pressed', isActive);
      option.setAttribute('tabindex', isActive ? '0' : '-1');
    });

    updateSliderDisplay();
    updateDescription();
    refreshRingsIfNeeded();
  }

  unitOptions.forEach(option => {
    option.addEventListener('click', () => {
      setUnitSelection(option.dataset.unit);
    });

    option.addEventListener('keydown', event => {
      if (event.key === 'ArrowRight' || event.key === 'ArrowLeft') {
        event.preventDefault();
        const currentIndex = unitOptions.indexOf(option);
        const direction = event.key === 'ArrowRight' ? 1 : -1;
        const nextIndex = (currentIndex + direction + unitOptions.length) % unitOptions.length;
        const nextOption = unitOptions[nextIndex];
        nextOption.focus();
        setUnitSelection(nextOption.dataset.unit);
      }
    });
  });

  ringSpacingSlider.addEventListener('input', () => {
    baseSpacingKm = Number(ringSpacingSlider.value);
    updateSliderDisplay();
    updateDescription();
    refreshRingsIfNeeded();
  });

  updateSliderDisplay();
  setUnitSelection(useMiles ? 'mi' : 'km');

  function drawCentralRings(latlng) {
    markerLayer.clearLayers();
    ringsLayer.clearLayers();

    L.marker(latlng, { title: 'Selected centre' }).addTo(markerLayer);

    const ringDistancesKm = getRingDistancesKm();

    ringDistancesKm.forEach(distanceKm => {
      const radiusMeters = distanceKm * 1000;
      const circle = L.circle(latlng, {
        radius: radiusMeters,
        color: '#222',
        weight: 2,
        fillColor: '#2b8a3e',
        fillOpacity: 0.1
      }).addTo(ringsLayer);

      // Calculate a point on the circle (45 degrees / northeast)
      const earthRadius = 6371000; // meters
      const bearing = 45; // degrees
      const lat1 = latlng.lat * Math.PI / 180;
      const lon1 = latlng.lng * Math.PI / 180;
      const angularDistance = radiusMeters / earthRadius;
      const bearingRad = bearing * Math.PI / 180;

      const lat2 = Math.asin(
        Math.sin(lat1) * Math.cos(angularDistance) +
        Math.cos(lat1) * Math.sin(angularDistance) * Math.cos(bearingRad)
      );
      const lon2 = lon1 + Math.atan2(
        Math.sin(bearingRad) * Math.sin(angularDistance) * Math.cos(lat1),
        Math.cos(angularDistance) - Math.sin(lat1) * Math.sin(lat2)
      );

      const labelPosition = L.latLng(lat2 * 180 / Math.PI, lon2 * 180 / Math.PI);

      // Convert to appropriate unit for display
      const displayDistance = useMiles ? Math.round(distanceKm * 0.621371) : Math.round(distanceKm);
      const unit = useMiles ? 'mi' : 'km';

      // Add label marker at the calculated position
      L.marker(labelPosition, {
        icon: L.divIcon({
          className: 'ring-label-marker',
          html: `<div class="ring-label">${displayDistance} ${unit}</div>`,
          iconSize: null
        })
      }).addTo(ringsLayer);
    });
  }

  map.on('click', event => {
    drawCentralRings(event.latlng);
  });

  // Provide an initial example so users see the behaviour immediately.
  drawCentralRings(map.getCenter());
  } catch (error) {
    console.error('Map initialization failed:', error);
    // Map will not be available, but video feeds will still work
  }
});
  </script>
</body>
</html>
